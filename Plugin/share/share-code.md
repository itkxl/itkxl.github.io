## 一、背景
1、Phantom框架在初版设计思想为：各插件隔离，每个插件拥有独立的ClassLoader和Resource、
- 优点：
    - 杜绝了资源冲突问题（宿主与插件，插件与插件），不要像atlas、VirtualApk之类的需要魔改aapt,做资源ID区分
    - 杜绝了类冲突的问题（宿主与插件，插件与插件），宿主和插件可以使用相同的公共库（例如support），不会冲突。
- 缺点：
    - 各插件依赖的公共库在每个插件中都有一份拷贝，插件apk体积较大。

2、待解决的问题
- 目前插件依赖的模块比较多（三方库，项目组内部的公共库），导致插件体积较大、
- 每个插件使用独立的ImageLoader,Scheduler,其内部都半酣线程池，插件越多，资源消耗越多，系统负担加重。

## 二、解决方案
由于各个插件依赖的模块（第三方库，内部公共组件）基本都是相同的，宿主也在使用，因此将各个插件需要使用的库/服务剥离出来，统一在宿主中实现，达到共享和复用的目的，既可以解决前面提到的问题。

### 2.1 方案一
对于宿主中的已有的公共库，插件使用宿主中的公共库，公共库不打包到插件中

#### 2.1.1 实现方式一
对于宿主中已有的公共库，宿主使用implementation依赖，插件使用provided依赖
- 优点
    - 插件中的APK中不包含宿主已提供的公共库代码，减少插件Apk大小
    - 工作量小，插件直接使用公共库提供的API
- 限制
    - 插件和宿主的依赖的公共库版本必须是同一个版本，不然插件可能运行中崩溃（找不到方法或者方法签名不对）。
    - 插件provided依赖的公共库不能混淆

#### 2.1.2 实现方式二
对宿主中和插件都使用到的公共库，宿主和插件都使用implementation依赖,单独开发一个Gradle插件，在打包插件Apk的时候将公共库的class移除掉
- 优点
    - 插件中Apk不包含宿主中提供的公共库代码，减少插件Apk大小
    - 插件直接使用公共库的api
- 限制
    - 插件和宿主的依赖的公共库版本必须是同一个版本，不然插件可能运行中崩溃（找不到方法或者方法签名不对）。
    - 插件provided依赖的公共库不能混淆

#### 2.1.3 注意事项
- 上面提到的内容都是和class相关，没有提到资源相关。公共库需要使用的资源都包含在宿主中，由于之前Phantom对宿主资源和插件资源进行了隔离，所以当公共库需要使用Context来访问资源的时候，这里的Context目前必须是宿主的Context,插件传递的时候需要注意
- 当公共库的入参需要传入插件的资源的时候，插件不能以R.xx.xx的方式已传递资源id给公共库，而是应该直接传递资源（String/Drawable）

#### 2.1.4 公共库版本依赖
前面两个实现方式都提到一个点，**宿主和插件的依赖库版本必须是同一版本，不然插件运行时可能崩溃**。
为了避免因为这个问题导致的崩溃，需要在加载插件前对依赖的组件库的版本进行比对。
- 插件：打包过程中，将自身组件库的dependencies信息生成provider_dependencies.txt，放在插件assets目录中
- 宿主：打包过程中，将宿主使用的组件库的dependencies信息生成compile_depencies.txt，放在宿主中的assets目录中
- 宿主在启动插件的过程中，将上述两者的信息读取出来，进行比较，如果前者不是后者的子集，则安装失败。
- 两个文件都上传到插件管理平台，动态下发插件的时候，可以提前进行判断。

### 2.2 方案二
宿主使用PhantomService将服务暴露给插件使用
- 优点：宿主和插件可以独立演化，宿主服务只需要保证接口的兼容，内部实现可以随意变化。
- 缺点：需要将目前的公共组件库包装成PhantomService暴露给插件调用，有额外工作量。


插件读一宿主的PhantomService的版本依赖
参考maven，引入服务坐标的概念，包含两个属性
- name:String 服务名称
- version:int 服务版本号

1、插件在其 AndroidManifest.xml 中用 meta-data 标签声明其依赖的宿主 服务名称 和 最小版本号
2、宿主向插件框架注册其提供的服务(包含 服务名称 和 版本号 )
3、宿主调用插件框架安装插件时，插件框架会检查宿主是否满足插件依赖的各个服务的最小版本号要求(即：宿主提供的服务版本号必须 >= 插件依赖的服务版本号)。若不满足，则安装失败
4、版本管理系统客户端 SDK 在检查插件升级时会上传宿主提供的服务信息(包含 服务名称 和 版本号)，Server 端根据插件声明服务依赖信息过滤掉不满足要求的插件版本
5、PhantomService 接口兼容性：只允许增加方法，不允许修改/删除方法。接口变动时，需要升级服务版本号。


### 2.3 方案三
在公共库智商提供一层封装（HostSDK）给插件使用，插件以provided方式依赖该封装层公共库。
- 优点：相对于不够稳定的各个公共库，可以对插件提供相对稳定的封装层。
- 缺点：工作量较大，与插件依赖的公共库数量成正比。

插件对封装层的版本依赖：
1、参考 Android SDK, 封装层公共库定义版本号
2、插件 AndroidManifest.xml 通过 meta-data 元素声明对封装层公共库版本依赖
3、宿主调用插件框架安装插件时，插件框架会检查宿主是否满足插件依赖的封装层公共库的最小版本号要求。若不满足，则安装失败
4、版本管理系统客户端 SDK 在检查插件升级时会上传宿主提供的封装层公共库的版本，Server 端根据插件声明封装层公共库最小版本过滤掉不满足要求的插件版本
5、封装层公共库接口兼容性： 1. 接口/类/方法，只允许增加，不允许修改或删除 2. 接口变动时，需要升级封装层公共库版本号。


## 三、补充
方案二中关于资源调用的Context问题，为了减少业务插件的改动，后续增加了一个处理，允许插件与宿主的资源进行合并，主要需要解决两个问题
- 资源id冲突
- 
