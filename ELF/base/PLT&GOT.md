本节将概述一下，日常开发过程中，.c文件最终编译成.so的基本过程以及涉及到与PLT/GOT Hook相关的知识。仅为概述，感兴趣的同学可以阅读一下《程序员的自我修养-链接、装载与库》这本书。

## 一、编译过程
接下来将以最简单的打印hello world为例。
```cpp
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}

```
### 1.1 预编译
- 目的：处理源代码中的预处理指令，比如宏定义（"define"）,文件引入（"inclde"）,条件编译（"#ifdef","endif"）等。
- 具体操作：
    - 宏替换：将所有的宏定义替换成相应的值或者是代码片段
    - 引入文件：将"#include"指令指向的文件内容插入到指令出现的文职
    - 条件编译：根据指定的条件编译指令。
预编译是发生在编译的真正过程之前的，它不生成任何机器码，而是输出一个“清理”过的源代码版本，去除了所有的宏定义，解析了所有的包含指令，处理了所有的条件编译指令。这个处理过的源代码接下来才会被送到编译器进行编译。这样做的目的是简化编译器的工作，因为预处理器已经处理掉了源代码中的复杂性和依赖性。

以hello world为例，其经过预编译后得产物大概如下
```cpp
extern int printf (const char *__restrict __format, ...);
//省略了stdio.h中其他的方法

int main() {
    printf("Hello, World!\n");
    return 0;
}

```

### 1.2 编译
- 目的：将源代码转换成汇编语言。
- 具体操作：编译器会对源代码进行词法分析、语法分析、语义分析和代码生成。首先，编译器会将代码分解成基本的元素（词法分析），然后根据语言的语法规则构建语法树（语法分析）。接着，检查语法树中的语义错误并进行类型检查（语义分析）。最后，编译器将语法树转换为汇编代码。

以hello world为例，其经过编译后得产物大概如下
```assembly
	.file	"hello.c"
	.text
	.section	.rodata
.LC0:
	.string	"hello world!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
```
这里可以核心关注一下 call	printf@PLT，后续会有详细介绍。

### 1.3 汇编
- 目的：将汇编语言转换为机器语言（即目标代码）。
- 具体操作：汇编器将汇编代码转换为机器代码。汇编语言是一种低级语言，更接近于机器语言，但仍具有可读性。汇编过程将这些符号语言翻译为机器能直接理解的指令。

以hello world为例，其经过汇编后得产物大概如下
```vbnet
节头：
  [号] 名称              类型             地址              偏移量
       大小              全体大小          旗标   链接   信息   对齐
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000023  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00000198
       0000000000000030  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000063
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  00000063
       0000000000000000  0000000000000000  WA       0     0     1
  [ 5] .rodata           PROGBITS         0000000000000000  00000063
       000000000000000d  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  00000070
       0000000000000026  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000096
       0000000000000000  0000000000000000           0     0     1
  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000098
       0000000000000020  0000000000000000   A       0     0     8
  [ 9] .eh_frame         PROGBITS         0000000000000000  000000b8
       0000000000000038  0000000000000000   A       0     0     8
  [10] .rela.eh_frame    RELA             0000000000000000  000001c8
       0000000000000018  0000000000000018   I      11     9     8
  [11] .symtab           SYMTAB           0000000000000000  000000f0
       0000000000000090  0000000000000018          12     4     8
  [12] .strtab           STRTAB           0000000000000000  00000180
       0000000000000015  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  000001e0
       0000000000000074  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

There are no section groups in this file.

本文件中没有程序头。

There is no dynamic section in this file.

重定位节 '.rela.text' at offset 0x198 contains 2 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
00000000000b  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000018  000500000004 R_X86_64_PLT32    0000000000000000 printf - 4

重定位节 '.rela.eh_frame' at offset 0x1c8 contains 1 entry:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
No processor specific unwind information to decode

Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     4: 0000000000000000    35 FUNC    GLOBAL DEFAULT    1 main
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf

```


### 1.4 链接
- 目的：将多个不同的目标文件（.o 文件）合并成一个单一的可执行文件或库文件（如.so）。
- 具体操作：链接器处理不同源文件之间的依赖关系，解决外部引用/符号的问题，并确保所有必需的代码和资源都被合并到最终的可执行文件中。例如，如果你的程序调用了标准库函数，链接器将确保这些函数的代码被加入到最终的程序中。


链接后的产物信息也相对较多，此处仅介绍一下其与汇编的产物的增加项。
- 符号解析与重定位：
    - 汇编后：符号表存在，但符号未解析，重定位信息表明如何调整符号。
    - 链接后：符号已被解析，所有引用都指向正确的地址。重定位信息现在指向实际依赖的库函数等。
- 节的增加：增加了多个与动态链接相关的节，如 .dynsym、.got 和 .dynamic等。
    - .dynsym:动态符号表，用于运行时符号解析
    - .dynamic:包含动态链接器需要各种参数和信息
    - .got:全局偏移表，存储全局数据和函数的地址。
  


## 二、动态链接
编译过程包括预编译、编译、汇编和链接。在这些阶段中，源代码逐步转化为机器代码。不过，当代码中调用的方法是外部调用时（需要调用系统的so或者其他三方编译好的so，比如hello world中使用的printf方法），外部调用的最终地址在编译和链接时并不确定（没办法在编译print方法时，确定这个方法在系统中的位置），而是留待程序运行时由动态链接器解析。这就引入了动态链接。

动态链接涉及到在程序运行时解析外部库函数和变量的地址。为了支持这一机制，编译器和链接器使用了特殊的数据结构，即GOT和PLT，来管理那些在运行时才能确定具体内存地址的符号。


### 2.1 GOT&PLT
GOT和PLT在整个动态链接的过程中，扮演着十分重要的角色，了解这两个节，有利于理解动态链接以及Hook操作的原理。
- GOT表：全局通讯录
设想一下，你在一个巨大的公司工作，但你不直接知道每个人的办公室在哪里。这里，GOT就像是一个不断更新的公司通讯录。当你需要找到某个部门（在这里是动态库中的函数或变量）时，你查看这个通讯录，找到他们当前的“位置”（也就是内存地址）。这个通讯录是活的，意味着某个人的办公室位置（函数地址）可能会改变（比如库更新了），但只要查看最新的通讯录（GOT），你总能找到正确的房间。

- PLT表：智能查找工具
在程序运行时，每当它需要调用一个动态链接的函数或访问一个变量时，它首先查看 GOT（通讯录）以获得地址。如果这是程序第一次访问某个函数，它还会通过 PLT（智能查找工具）触发动态链接器工作，动态链接器负责找到这些外部函数的真实地址，并更新到 GOT 中。

### 2.2 基本流程

在2.1中简单介绍了GOT和PLT表的基本作用，两者在动态链接中配合使用，流程通常如下：
- PLT入口调用：程序中的代码不直接跳转到函数实际的地址，而是跳转到PLT中该函数对应的入口。
- PLT重定向：如果是第一次调用，PLT入口将控制权转交给动态链接器，动态链接器查询该函数的实际地址，将其写入GOT，并修改PLT入口使得后续的调用可以直接跳转到GOT中的地址。
- GOT访问：在PLT进行了初次调用后的设置，后续的函数调用将通过PLT快速定位到GOT中的地址，从而实现对函数的直接调用。

通过这种方式，程序在首次调用函数时会有一些性能损失，因为涉及到动态链接器的查询和地址修正。但在首次调用之后，函数的调用变得非常快速，因为地址已经解析并存储在GOT中了。


### 2.3 动态链接涉及到的节
除了GOT表和PLT表之外，在动态链接的过程中，还涉及到其他的节。

#### 2.3.1 .dynsym (Dynamic Symbol Table)
功能：存储动态链接符号信息，包括函数和变量等，这些符号可能被其他模块或动态库引用。
目的：提供一个符号索引，使得动态链接器可以在运行时解析符号地址。
```
Symbol table '.dynsym' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]
     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2.2.5 (2)
     6: 0000000000001119    35 FUNC    GLOBAL DEFAULT   14 main
```

#### 2.3.2 .dynamic
功能：存储动态链接符号信息，包括函数和变量等，这些符号可能被其他模块或动态库引用。
目的：提供一个符号索引，使得动态链接器可以在运行时解析符号地址。
```
Dynamic section at offset 0x2e08 contains 24 entries:
  标记        类型                         名称/值
 0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
 0x000000000000000c (INIT)               0x1000
 0x000000000000000d (FINI)               0x113c
 0x0000000000000019 (INIT_ARRAY)         0x3df8
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x3e00
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x2f0
 0x0000000000000005 (STRTAB)             0x3c0
 0x0000000000000006 (SYMTAB)             0x318
 0x000000000000000a (STRSZ)              119 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000003 (PLTGOT)             0x3fe8
 0x0000000000000002 (PLTRELSZ)           24 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x510
 0x0000000000000007 (RELA)               0x468
 0x0000000000000008 (RELASZ)             168 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffe (VERNEED)            0x448
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x438
 0x000000006ffffff9 (RELACOUNT)          3
 0x0000000000000000 (NULL)               0x0
```
- NEEDED：表明该 ELF 文件在运行时需要加载的共享库。
- INIT/FINI：指定了初始化和终止函数的地址。
- INIT_ARRAY/FINI_ARRAY：指向初始化和终结函数数组的地址，这些数组包含了在程序启动和结束时需要调用的函数指针。
- GNU_HASH：指向 .gnu.hash 表的地址，这是优化的哈希表，用于快速符号查找。
- STRTAB/SYMTAF：字符串表和符号表的地址，这些是动态链接中解析符号时必需的。

#### 2.3.3 .rela.text 和 .rela.data
功能：包含针对代码段（.text）和数据段（.data）的重定位信息。每个条目指明如何修改代码或数据来引用正确的地址。
目的：支持对内部和外部符号引用的修正。
```
重定位节 '.rela.text' at offset 0x198 contains 2 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
00000000000b  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000018  000500000004 R_X86_64_PLT32    0000000000000000 printf - 4
```

#### 2.3.4 .rela.plt
功能：包含特定于过程链接表的重定位信息，用于在运行时解析动态库函数的地址。
目的：确保 .plt 中的跳转指向正确的函数实现。
```
重定位节 '.rela.plt' at offset 0x510 contains 1 entry:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000004000  000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
No processor specific unwind information to decode
```

#### 2.3.5 .hash 或 .gnu.hash
功能：提供快速的符号查找机制，通过哈希表可以快速定位符号在 .dynsbym 中的位置。
目的：加速动态链接过程中的符号解析，提高运行效率。

## 三、学习过程中的疑问
#### 3.1 .got.plt 与 .rela.plt 有什么关系以及区别?
- 关系：.rela.plt 和 .got.plt 是协同工作的。.rela.plt 中的重定位条目用于初始化和更新 .got.plt 中的地址。在程序执行过程中，当第一次调用到 PLT 中的函数时，会利用 .rela.plt 中的信息来填充 .got.plt 中相应函数的正确地址。
- 区别：.got.plt 直接存储函数地址，供程序中的跳转指令直接使用；而 .rela.plt 存储的是如何找到并设置这些地址的指示信息。

#### 3.2 .got.plt 与.got的区别？
.got 主要用于全局变量和一些非通过 PLT 调用的函数地址，而 .got.plt 专门用于通过 PLT 调用的动态链接函数的地址。

#### 3.3 .got、.plt、.got.plt三者的关系与区别？
- .got
    - 概念：.got 是一个在运行时填充的表，用于存储那些地址在编译时无法确定的全局变量和函数的实际内存地址。
    - 功能：它使得程序可以在运行时动态地访问和修改全局数据和函数的地址，这对于使用动态链接库极为重要。程序中的代码通过间接引用 .got 来访问这些全局变量和函数，这样即使它们的地址发生变化（例如，通过加载不同版本的共享库），代码仍然可以正常工作。当然，也为Hook功能提供了便利。
    - 填充机制：一般在共享库被加载到内存的时候，链接器就会将.got表填充。
- .plt
    - 概念：.plt 是一个包含跳转指令的表，专门用于管理动态链接函数的调用。
    - 功能：当程序首次调用一个动态链接的函数时，控制权会转移到 .plt 中该函数对应的入口。这个入口包含的指令会进一步跳转到 .got.plt 中存储的地址，该地址最初会指回 .plt 中的另一部分，触发解析器代码。
- .got.plt 
    - 概念：.got.plt 是 .got 的一部分，专门用于存储通过 PLT 调用的函数的地址。
    - 功能：在程序运行时，.got.plt 存储的地址最初指向 .plt 中的解析器代码，这保证了函数在首次调用时能够被动态链接器解析。一旦函数的真实地址被解析，它会被更新到 .got.plt 中，以便后续调用可以直接利用这个地址，从而加速函数调用过程。
- .plt&.got.plt的协作机制
    - 1、初始调用：当程序首次调用一个动态链接的函数时，执行流程跳转到 .plt。
    - 2、PLT 跳转：.plt 中的指令将执行流程进一步跳转到 .got.plt 指定的地址，该地址最初会回跳到 .plt 中的解析器。
    - 3、解析地址：解析器通过动态链接器调用，解析函数的实际内存地址，并将此地址更新到 .got.plt 中相应的条目。
    - 4、更新后的调用：之后的所有对该函数的调用将直接通过 .got.plt 中更新的地址，从而避免重复解析，加速执行。